#include "cli_vcp.h"
#include "cli_shell.h"
#include <furi_hal_usb_cdc.h>
#include <furi_hal.h>
#include <furi.h>
#include <stdint.h>

#define TAG "CliVcp"

#define USB_CDC_PKT_LEN CDC_DATA_SZ
#define VCP_BUF_SIZE    (USB_CDC_PKT_LEN * 3)

#define VCP_IF_NUM 0

#define VCP_MESSAGE_Q_LEN 8

typedef struct {
    enum {
        CliVcpMessageTypeEnable,
        CliVcpMessageTypeDisable,
    } type;
    union {};
} CliVcpMessage;

typedef enum {
    CliVcpInternalMessageConnected,
    CliVcpInternalMessageDisconnected,
    CliVcpInternalMessageTxDone,
    CliVcpInternalMessageRx,
} CliVcpInternalMessage;

struct CliVcp {
    FuriEventLoop* event_loop;
    FuriMessageQueue* message_queue; // <! external messages
    FuriMessageQueue* internal_message_queue;

    bool is_enabled, is_connected;
    FuriHalUsbInterface* previous_interface;

    FuriPipeSide* own_pipe;
    bool is_currently_transmitting;
    size_t previous_tx_length;

    FuriThread* shell;
};

// ============
// Data copying
// ============

/**
 * Called in the following cases:
 *   - previous transfer has finished;
 *   - new data became available to send.
 */
static void cli_vcp_maybe_send_data(CliVcp* cli_vcp) {
    if(cli_vcp->is_currently_transmitting) return;
    if(!cli_vcp->own_pipe) return;

    uint8_t buf[USB_CDC_PKT_LEN];
    size_t length = furi_pipe_receive(cli_vcp->own_pipe, buf, sizeof(buf), 0);
    if(length > 0 || cli_vcp->previous_tx_length == USB_CDC_PKT_LEN) {
        FURI_LOG_T(TAG, "cdc_send length=%zu", length);
        cli_vcp->is_currently_transmitting = true;
        furi_hal_cdc_send(VCP_IF_NUM, buf, length);
    }
    cli_vcp->previous_tx_length = length;
}

/**
 * Called in the following cases:
 *   - new data arrived at the endpoint;
 *   - data was read out of the pipe.
 */
static void cli_vcp_maybe_receive_data(CliVcp* cli_vcp) {
    if(!cli_vcp->own_pipe) return;
    if(furi_pipe_spaces_available(cli_vcp->own_pipe) < USB_CDC_PKT_LEN) return;

    uint8_t buf[USB_CDC_PKT_LEN];
    size_t length = furi_hal_cdc_receive(VCP_IF_NUM, buf, sizeof(buf));
    FURI_LOG_T(TAG, "cdc_receive length=%zu", length);
    furi_check(furi_pipe_send(cli_vcp->own_pipe, buf, length, 0) == length);
}

// =============
// CDC callbacks
// =============

static void cli_vcp_send_internal_message(CliVcp* cli_vcp, CliVcpInternalMessage message) {
    furi_check(
        furi_message_queue_put(cli_vcp->internal_message_queue, &message, 0) == FuriStatusOk);
}

static void cli_vcp_cdc_tx_done(void* context) {
    CliVcp* cli_vcp = context;
    cli_vcp_send_internal_message(cli_vcp, CliVcpInternalMessageTxDone);
}

static void cli_vcp_cdc_rx(void* context) {
    CliVcp* cli_vcp = context;
    cli_vcp_send_internal_message(cli_vcp, CliVcpInternalMessageRx);
}

static void cli_vcp_cdc_state_callback(void* context, CdcState state) {
    CliVcp* cli_vcp = context;
    if(state == CdcStateDisconnected) {
        cli_vcp_send_internal_message(cli_vcp, CliVcpInternalMessageDisconnected);
    }
    // `Connected` events are generated by DTR going active
}

static void cli_vcp_cdc_ctrl_line_callback(void* context, CdcCtrlLine ctrl_lines) {
    CliVcp* cli_vcp = context;
    if(ctrl_lines & CdcCtrlLineDTR) {
        cli_vcp_send_internal_message(cli_vcp, CliVcpInternalMessageConnected);
    } else {
        cli_vcp_send_internal_message(cli_vcp, CliVcpInternalMessageDisconnected);
    }
}

static CdcCallbacks cdc_callbacks = {
    .tx_ep_callback = cli_vcp_cdc_tx_done,
    .rx_ep_callback = cli_vcp_cdc_rx,
    .state_callback = cli_vcp_cdc_state_callback,
    .ctrl_line_callback = cli_vcp_cdc_ctrl_line_callback,
    .config_callback = NULL,
};

// ==================
// EventLoop handlers
// ==================

static void cli_vcp_data_from_shell(FuriEventLoopObject* object, void* context) {
    UNUSED(object);
    CliVcp* cli_vcp = context;
    cli_vcp_maybe_send_data(cli_vcp);
}

static void cli_vcp_shell_ready(FuriEventLoopObject* object, void* context) {
    UNUSED(object);
    CliVcp* cli_vcp = context;
    FURI_LOG_T(TAG, "shell_ready");
    cli_vcp_maybe_receive_data(cli_vcp);
}

/**
 * Processes messages arriving from other threads
 */
static void cli_vcp_message_received(FuriEventLoopObject* object, void* context) {
    CliVcp* cli_vcp = context;
    CliVcpMessage message;
    furi_check(furi_message_queue_get(object, &message, 0) == FuriStatusOk);

    switch(message.type) {
    case CliVcpMessageTypeEnable:
        if(cli_vcp->is_enabled) return;
        FURI_LOG_D(TAG, "Enabling");
        cli_vcp->is_enabled = true;

        // switch usb mode
        cli_vcp->previous_interface = furi_hal_usb_get_config();
        furi_hal_usb_set_config(&usb_cdc_single, NULL);
        furi_hal_cdc_set_callbacks(VCP_IF_NUM, &cdc_callbacks, cli_vcp);
        break;

    case CliVcpMessageTypeDisable:
        if(!cli_vcp->is_enabled) return;
        FURI_LOG_D(TAG, "Disabling");
        cli_vcp->is_enabled = false;

        // restore usb mode
        furi_hal_cdc_set_callbacks(VCP_IF_NUM, NULL, NULL);
        furi_hal_usb_set_config(cli_vcp->previous_interface, NULL);
        break;
    }
}

/**
 * Processes messages arriving from CDC event callbacks
 */
static void cli_vcp_internal_message_received(FuriEventLoopObject* object, void* context) {
    CliVcp* cli_vcp = context;
    CliVcpInternalMessage message;
    furi_check(furi_message_queue_get(object, &message, 0) == FuriStatusOk);

    switch(message) {
    case CliVcpInternalMessageTxDone:
        FURI_LOG_T(TAG, "TxDone");
        cli_vcp->is_currently_transmitting = false;
        cli_vcp_maybe_send_data(cli_vcp);
        break;

    case CliVcpInternalMessageRx:
        FURI_LOG_T(TAG, "Rx");
        cli_vcp_maybe_receive_data(cli_vcp);
        break;

    case CliVcpInternalMessageDisconnected:
        if(!cli_vcp->is_connected) return;
        FURI_LOG_D(TAG, "Disconnected");
        cli_vcp->is_connected = false;

        // disconnect our side of the pipe
        furi_event_loop_unsubscribe(cli_vcp->event_loop, cli_vcp->own_pipe);
        furi_pipe_free(cli_vcp->own_pipe);
        cli_vcp->own_pipe = NULL;
        break;

    case CliVcpInternalMessageConnected:
        if(cli_vcp->is_connected) return;
        FURI_LOG_D(TAG, "Connected");
        cli_vcp->is_connected = true;

        // wait for previous shell to stop
        furi_check(!cli_vcp->own_pipe);
        if(cli_vcp->shell) {
            furi_thread_join(cli_vcp->shell);
            furi_thread_free(cli_vcp->shell);
        }

        // start shell thread
        FuriPipe pipe = furi_pipe_alloc(VCP_BUF_SIZE, 1);
        cli_vcp->own_pipe = pipe.alices_side;
        furi_event_loop_subscribe_pipe(
            cli_vcp->event_loop,
            cli_vcp->own_pipe,
            FuriEventLoopEventIn | FuriEventLoopEventFlagEdge,
            cli_vcp_data_from_shell,
            cli_vcp);
        furi_event_loop_subscribe_pipe(
            cli_vcp->event_loop,
            cli_vcp->own_pipe,
            FuriEventLoopEventOut | FuriEventLoopEventFlagEdge,
            cli_vcp_shell_ready,
            cli_vcp);
        furi_delay_ms(33); // we are too fast, minicom isn't ready yet
        cli_vcp->shell = cli_shell_start(pipe.bobs_side);
        break;
    }
}

// ============
// Thread stuff
// ============

static CliVcp* cli_vcp_alloc(void) {
    CliVcp* cli_vcp = malloc(sizeof(CliVcp));

    cli_vcp->event_loop = furi_event_loop_alloc();

    cli_vcp->message_queue = furi_message_queue_alloc(VCP_MESSAGE_Q_LEN, sizeof(CliVcpMessage));
    furi_event_loop_subscribe_message_queue(
        cli_vcp->event_loop,
        cli_vcp->message_queue,
        FuriEventLoopEventIn,
        cli_vcp_message_received,
        cli_vcp);

    cli_vcp->internal_message_queue =
        furi_message_queue_alloc(VCP_MESSAGE_Q_LEN, sizeof(CliVcpInternalMessage));
    furi_event_loop_subscribe_message_queue(
        cli_vcp->event_loop,
        cli_vcp->internal_message_queue,
        FuriEventLoopEventIn,
        cli_vcp_internal_message_received,
        cli_vcp);

    return cli_vcp;
}

int32_t cli_vcp_srv(void* p) {
    UNUSED(p);

    if(furi_hal_rtc_get_boot_mode() != FuriHalRtcBootModeNormal) {
        FURI_LOG_W(TAG, "Skipping start in special boot mode");
        furi_thread_suspend(furi_thread_get_current_id());
        return 0;
    }

    CliVcp* cli_vcp = cli_vcp_alloc();
    furi_record_create(RECORD_CLI_VCP, cli_vcp);
    furi_event_loop_run(cli_vcp->event_loop);

    return 0;
}

// ==========
// Public API
// ==========

void cli_vcp_enable(CliVcp* cli_vcp) {
    CliVcpMessage message = {
        .type = CliVcpMessageTypeEnable,
    };
    furi_message_queue_put(cli_vcp->message_queue, &message, FuriWaitForever);
}

void cli_vcp_disable(CliVcp* cli_vcp) {
    CliVcpMessage message = {
        .type = CliVcpMessageTypeDisable,
    };
    furi_message_queue_put(cli_vcp->message_queue, &message, FuriWaitForever);
}
